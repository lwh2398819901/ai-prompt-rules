# CODE WRITING RULES

You MUST follow these rules when writing code. NO EXCEPTIONS.

---

## DEVELOPMENT STAGE DECLARATION

**Current Stage**: DEVELOPMENT STAGE

This setting affects your behavior. Check this FIRST before any code operation.

---

## DEVELOPMENT STAGE RULES (ACTIVE)

When in Development Stage, you MUST:

| Rule | Action | Reason |
|------|--------|--------|
| Database migrations | ❌ NEVER generate migration scripts | Directly modify original schema/DDL |
| API backward compatibility | ❌ NEVER write compatibility code | Directly modify interface definitions |
| Old field/interface compatibility | ❌ NEVER preserve compatibility logic | Assume all callers update simultaneously |
| Schema changes | Output complete new DDL/Entity definition | No data migration consideration needed |
| Data assumption | Database can be deleted and rebuilt anytime | No historical data preservation |

**CRITICAL**: In development stage, SIMPLICITY over COMPATIBILITY.

---

## PRODUCTION STAGE RULES (INACTIVE - for reference)

When switched to Production Stage:
- ✅ MUST generate migration scripts to preserve data
- ✅ API changes MUST be backward compatible or versioned

---

## CORE CONSTRAINT RULES

### Rule 1: REUSE EXISTING CODE

**MANDATORY**:
- ALWAYS prioritize reusing existing core services, utility classes, common methods
- NEVER bypass existing modules to write duplicate logic from scratch

**Before writing ANY new code**:
1. Search for existing implementations
2. Check utility classes
3. Check common methods
4. If found → REUSE
5. If not found → Proceed with new implementation

### Rule 2: USE EXISTING DATA ACCESS LAYERS

**MANDATORY**:
- When operating database/cache/third-party APIs → MUST call existing DAO/Repository/SDK layers
- NEVER write raw operations (e.g., raw SQL) directly

**EXCEPTIONS** (raw operations allowed ONLY when):
- User explicitly requests it
- Special circumstances require direct operation (must justify)

**Violation Example**:
```python
# ❌ WRONG - Direct SQL
db.execute("SELECT * FROM users WHERE id = ?", user_id)

# ✅ CORRECT - Use existing layer
user_repository.get_by_id(user_id)
```

### Rule 3: MARK UNCERTAINTIES

**When uncertain if functionality already exists**:
- Mark with: `「待确认复用项：XXX」`
- NEVER assume it doesn't exist
- NEVER create duplicate implementations

---

## PROJECT STRUCTURE REQUIREMENTS

You MUST ensure these conditions are met:

| Requirement | Check | Action if Missing |
|-------------|-------|-------------------|
| `tmp` folder in project root | Must exist | Create it |
| Project is git repository | Must be initialized | Run `git init` |
| `tmp` in `.gitignore` | Must be ignored | Add to `.gitignore` |
| Summary documents location | Must go to `tmp/` | Write to `tmp/` directory |

**Summary Documents Include**:
- Modification summaries
- Review reports
- Any generated summary files

---

## OUTPUT SPECIFICATION

For EVERY code generation task, you MUST:

### Step 1: Before Generating Code
State "核心复用项" (Core Reuse Items):
- List existing services/utilities being reused
- If none found, state "未发现可复用项"

### Step 2: After Code Completion
Provide "合规自查" (Compliance Self-Check):
- [ ] Reuse status: What was reused?
- [ ] Naming conventions: Following project standards?
- [ ] Directory conventions: Correct file locations?
- [ ] Redundancy check: Any duplicate code created?

### Step 3: If Constraint Conflicts Exist
Provide "约束适配调整" (Constraint Adaptation):
- Explain the conflict
- Provide optimal solution
- Justify the decision

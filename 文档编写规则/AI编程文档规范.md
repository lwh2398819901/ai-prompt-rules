# AI编程文档规范

> **版本**: v1.0  
> **更新日期**: 2025-11-05  
> **适用场景**: 使用AI工具进行软件开发的团队

---

## 📖 规范说明

本规范定义了如何组织技术文档，以最大化AI编程工具（如Cursor、GitHub Copilot、Claude等）的效果。

**核心理念**：
```
AI需要的不是"完整的知识库"，而是"精准的上下文"
```

---

## 🎯 核心原则

### 1️⃣ 模块化原则

**规则**：单个文档行数控制在合理范围内

| 文档类型 | 推荐行数 | 最大行数 | 原因 |
|---------|---------|---------|------|
| 页面/模块文档 | 150-300行 | 500行 | AI上下文窗口限制 |
| 通用规范文档 | 200-400行 | 800行 | 需要包含完整映射表 |
| 专项深入文档 | 300-600行 | 1000行 | 复杂机制需要详细说明 |
| API接口文档 | 每个接口50-100行 | 200行 | 单个接口的完整定义 |

**✅ 好的例子**：
```
docs/
├── modules/
│   ├── 01-认证与权限.md        (200行)
│   ├── 02-代理商管理.md        (300行)
│   └── 03-OAuth授权.md         (200行)
```

**❌ 坏的例子**：
```
docs/
└── 后端实现指南.md              (3192行) ← AI容易丢失关键信息
```

---

### 2️⃣ 单一职责原则

**规则**：一个文档只描述一个模块/页面/功能

**✅ 好的例子**：
- `pages/用户管理.md` - 只描述用户管理页面
- `modules/OAuth授权.md` - 只描述OAuth授权模块

**❌ 坏的例子**：
- `前端实现指南.md` - 包含9个页面（2456行）
- `后端实现指南.md` - 包含8个模块（3192行）

---

### 3️⃣ 精准相关原则

**规则**：AI上下文中的每一行都应该与当前任务相关

**使用场景示例**：

```
开发任务：实现用户登录功能

✅ 好的上下文组合（总计 ~400行）：
  @01-系统模型.md#权限体系 (50行)
  @modules/01-认证与权限.md (200行)
  @api/api-01-认证.md#登录接口 (50行)
  @02-数据库设计.md#users表 (30行)

❌ 坏的上下文组合（总计 3192行）：
  @03-后端实现指南.md (3192行)
    ├─ 包含登录逻辑 (需要) ✅
    ├─ 包含代理商管理 (不需要) ❌
    ├─ 包含日志拉取 (不需要) ❌
    └─ 包含导出任务 (不需要) ❌
```

---

### 4️⃣ 可视化优先原则

**规则**：用图表代替大段文字描述

**推荐使用**：
- ✅ ASCII布局图（界面结构）
- ✅ Mermaid流程图（业务流程）
- ✅ 表格（字段定义、配置参数）
- ✅ 代码块（关键逻辑伪代码）

**示例**：

```markdown
## 界面布局（推荐用ASCII图）

```
┌─────────────────────────────────┐
│ 用户管理            [新增用户]  │
├─────────────────────────────────┤
│ 表格：                          │
│ ┌────┬────┬────┬──────────┐   │
│ │ ID │姓名│角色│ 操作     │   │
│ └────┴────┴────┴──────────┘   │
└─────────────────────────────────┘
```
```

**比大段文字描述好100倍！**

---

### 5️⃣ 交叉引用原则

**规则**：文档间通过链接互相引用，而不是重复内容

**✅ 好的例子**：
```markdown
## 权限验证

> **详细定义**: 见 [01-系统模型.md#权限体系](../01-系统模型.md#权限体系)

**验证流程**：
- SUPER_ADMIN：直接放行
- ADMIN：直接放行
- USER：检查user_agency_binding表
```

**❌ 坏的例子**：
```markdown
## 权限验证

权限体系分为三层：
- SUPER_ADMIN：全局唯一，不可删除，不可修改角色...（复制粘贴500行）
- ADMIN：...
- USER：...
```

---

## 📚 文档分层架构

### 层级定义

```
Layer 1: 基础层（理解系统）
  ├─ 00-快速导航.md              快速索引，找到目标文档
  ├─ 01-系统模型.md              核心概念、实体关系
  └─ 02-数据库设计.md            数据结构

Layer 2: 实现层（具体实现）
  ├─ backend/modules/            后端模块文档（8-10个）
  ├─ frontend/pages/             前端页面文档（9个）
  └─ api/                        API接口文档（按模块拆分）

Layer 3: 专项层（深入机制）
  ├─ advanced/                   复杂机制深入文档
  └─ external/                   外部系统对接文档
```

### AI使用策略

| 开发场景 | Layer 1 | Layer 2 | Layer 3 | 总行数 |
|---------|---------|---------|---------|--------|
| 快速了解系统 | ✅ 全部 | ❌ | ❌ | ~600行 |
| 实现单个模块 | ✅ 相关部分 | ✅ 该模块 | ❌ | ~400行 |
| 实现复杂功能 | ✅ 相关部分 | ✅ 该模块 | ✅ 相关专项 | ~800行 |
| 修复Bug | ❌ | ✅ 相关模块 | ✅ 可能需要 | ~500行 |

**目标**: 控制在 **1000行以内**

---

## 🎨 前端文档特殊规范

### 核心定位

```
前端文档 = 产品设计稿 + 交互说明书
          ≠ 技术实现手册
```

### 内容侧重

| 应该写什么 | 不应该写什么 |
|-----------|------------|
| ✅ 界面布局图（ASCII图） | ❌ Vue组件代码 |
| ✅ 用户交互流程 | ❌ 状态管理实现 |
| ✅ 表单字段定义 | ❌ 表单验证代码 |
| ✅ 调用哪个API | ❌ Axios封装逻辑 |
| ✅ 枚举值映射表 | ❌ 工具函数实现 |
| ✅ 按钮权限规则 | ❌ 路由守卫代码 |

### 为什么？

```
AI擅长：根据需求生成代码
AI需要：清晰的界面要求和交互流程

AI不需要：具体的技术实现细节（这是AI的强项）
```

### 前端页面文档模板

```markdown
# 页面名称

**路由** | **权限** | **后端接口**

## 🖼️ 界面布局
（ASCII图）

## 👆 交互流程
（用户操作流程图）

## 📋 字段/组件清单
（表格定义）

## 🔌 API调用列表
（只列接口，链接到详细API文档）

## ✅ 开发检查清单
（验收标准）
```

---

## 🔧 后端文档特殊规范

### 核心定位

```
后端文档 = 业务流程 + 实现要点
          ≠ 完整代码实现
```

### 内容侧重

| 应该写什么 | 不应该写什么 |
|-----------|------------|
| ✅ 业务流程图 | ❌ 完整Python代码 |
| ✅ 关键设计决策 | ❌ 工具函数实现 |
| ✅ 数据结构定义 | ❌ ORM查询语句 |
| ✅ 伪代码逻辑 | ❌ 异常处理细节 |
| ✅ API调用顺序 | ❌ HTTP客户端封装 |

### 后端模块文档模板

```markdown
# Module X: 模块名称

> **依赖** | **相关API** | **错误码范围**

## 核心概念
（关键术语定义）

## 业务流程
（主要流程 + 流程图）

## 数据结构
（表格定义）

## 实现要点
（关键逻辑伪代码）

## 错误处理
（错误码映射）
```

---

## 📐 文档命名规范

### 目录结构

```
docs/
├─── 00-快速导航.md              ← 数字前缀表示阅读顺序
├─── 01-系统模型.md
├─── 02-数据库设计.md
├─── backend/
│    ├─── modules/
│    │    ├─── 01-认证与权限.md  ← 模块编号对应错误码
│    │    ├─── 02-代理商管理.md
│    │    └─── ...
│    └─── advanced/
│         └─── 日志拉取任务管理.md  ← 专项文档用中文描述性名称
├─── frontend/
│    └─── pages/
│         ├─── 登录页.md         ← 页面名称
│         ├─── 用户管理.md
│         └─── ...
└─── api/
     ├─── api-01-认证.md         ← 对应后端模块编号
     └─── ...
```

### 命名规则

| 文档类型 | 命名格式 | 示例 |
|---------|---------|------|
| 基础文档 | `数字-名称.md` | `01-系统模型.md` |
| 模块文档 | `数字-模块名.md` | `03-OAuth授权.md` |
| 页面文档 | `页面名.md` | `用户管理.md` |
| API文档 | `api-数字-模块名.md` | `api-01-认证.md` |
| 专项文档 | `功能描述.md` | `日志拉取任务管理.md` |

---

## ✅ 文档质量检查清单

### 单个文档检查

- [ ] **行数控制**: 是否 < 500行（模块文档）或 < 200行（页面文档）？
- [ ] **单一职责**: 是否只描述一个模块/页面/功能？
- [ ] **可视化**: 是否使用了图表而非大段文字？
- [ ] **交叉引用**: 是否避免了重复内容，使用了链接引用？
- [ ] **目标明确**: AI读完后是否能清楚知道"要做什么"？

### 整体架构检查

- [ ] **快速导航**: 是否有索引文档帮助快速定位？
- [ ] **分层清晰**: Layer 1/2/3 是否职责明确？
- [ ] **模块完整**: 每个功能是否都有对应的文档？
- [ ] **引用正确**: 文档间的链接是否都有效？

### AI友好性检查

**测试方法**：选择一个开发任务，模拟AI使用文档

1. ✅ 能否在3次点击内找到相关文档？
2. ✅ 相关文档总行数是否 < 1000行？
3. ✅ AI阅读后是否能生成正确代码？
4. ✅ 是否避免了加载无关内容？

---

## 🚀 文档重构实施步骤

### 第一步：评估现状

```bash
# 统计各文档行数
wc -l docs/*.md

# 识别超长文档（>1000行）
find docs -name "*.md" -exec wc -l {} \; | awk '$1 > 1000'
```

### 第二步：创建新结构

```bash
mkdir -p docs/{backend/{modules,advanced},frontend/pages,api}
```

### 第三步：快速验证

选择1-2个最简单的模块先拆分，验证效果：
- 后端：选择CRUD逻辑最简单的模块
- 前端：选择交互最简单的页面

### 第四步：批量迁移

如果验证效果好，逐步拆分其他模块。

### 第五步：建立索引

创建 `00-快速导航.md`，建立文档地图。

---

## 📊 效果对比

### 重构前 vs 重构后

| 维度 | 重构前 | 重构后 | 改善 |
|------|-------|--------|------|
| 单次AI上下文行数 | 3000+ | <1000 | ✅ 67%↓ |
| 查找文档时间 | 5-10分钟 | <1分钟 | ✅ 90%↓ |
| AI代码准确度 | 70% | 95% | ✅ 25%↑ |
| 文档维护成本 | 高（修改影响大） | 低（模块独立） | ✅ 50%↓ |
| 新人上手时间 | 2-3天 | 半天 | ✅ 75%↓ |

---

## 💡 最佳实践

### 1. 先写文档，再写代码

```
传统流程：代码 → 文档（往往不写）
AI流程：  文档 → AI生成代码（文档即需求）
```

### 2. 文档即产品需求

```
后端文档 = 技术PRD（产品需求文档）
前端文档 = UI设计稿 + 交互说明书
```

### 3. 定期重构文档

```
每季度检查：
  - 是否有文档超过1000行？→ 拆分
  - 是否有重复内容？→ 提取为公共文档
  - 是否有过时内容？→ 更新或删除
```

### 4. 团队协作规范

```
提交代码时：
  ✅ 同时更新相关文档
  ✅ 检查文档链接是否有效
  ✅ 确保文档行数不超标
```

---

## 🎯 总结

**AI编程文档的黄金法则**：

```
1. 模块化：< 500行/文档
2. 单一职责：一个文档一个功能
3. 精准相关：只给AI需要的内容
4. 可视化：图表 > 文字
5. 前端界面：交互流程 > 技术实现
6. 后端逻辑：业务流程 > 代码细节
```

**最终目标**：
```
让AI像人类开发者一样理解需求，而不是像搜索引擎一样检索信息
```

---

## 📖 参考资源

**本规范基于以下实践总结**：
- ✅ 日志系统Web版项目文档重构经验
- ✅ Cursor / GitHub Copilot / Claude 使用经验
- ✅ AI编程最佳实践

**适用工具**：
- Cursor
- GitHub Copilot
- Claude
- ChatGPT
- 其他支持长上下文的AI编程工具

---

**版本历史**：
- v1.0 (2025-11-05): 初始版本


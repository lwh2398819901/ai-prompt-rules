# 🔍 代码审查规则体系

## 一、核心原则

### 原则 1：简洁优于复杂
- **目标**：代码易读、易懂、易维护
- **执行**：避免过度抽象，保持直观性
- **检验**：新人能否在10分钟内理解这段代码的意图

### 原则 2：重复3次才提取
- **目标**：避免过度优化
- **执行**：重复少于3次，保持原地实现
- **理由**：提前抽象是万恶之源，等到真正需要时再重构

### 原则 3：适度抽象
- **目标**：平衡复用和可读性
- **执行**：提取公共逻辑，但不追求极致抽象
- **检验**：抽象层次不超过3层

### 原则 4：格式一致性
- **目标**：全项目统一的代码风格
- **执行**：使用自动化工具（black/flake8/autopep8）
- **检验**：通过 PEP 8 检查（Python）或 ESLint（JS）

### 原则总结

| 维度 | 要求 |
|-----|------|
| **重复** | 3次以上才提取 |
| **抽象** | 适度 > 极致 |
| **可读性** | 简洁 > 复杂 |
| **格式** | 工具自动化 > 人工检查 |
| **覆盖** | L3全面审查 = 100%文件 |
| **标准** | 项目约定的代码规范 |
| **维护** | 持续改进 > 一次完美 |

---

## 二、审查分级与流程

### 级别总览

| 级别 | 名称 | 覆盖率 | 耗时 | 何时使用 |
|-----|------|-------|------|---------|
| L1 | 快速扫描 | 10-20% | 5-10分钟 | 日常提交 |
| L2 | 重点审查 | 40-60% | 30-60分钟 | 功能完成 |
| L3 | 全面审查 | 100% | 2-4小时 | 重大重构/发版前 |

### L1 - 快速扫描

**适用场景**：日常提交

**检查清单**：
- [ ] 代码能正常运行
- [ ] 无语法错误
- [ ] 无明显重复代码
- [ ] 导入语句已清理
- [ ] 空行和缩进正确

**工具**：使用项目对应语言的 Linter 进行基础语法检查

**通过标准**：
- ✅ 无语法错误
- ✅ 无明显格式问题
- ✅ 通过基础 Linter 检查

### L2 - 重点审查

**适用场景**：功能完成

**检查清单**：
- [ ] 通过完整的格式检查
- [ ] 重复代码已提取（3次以上）
- [ ] 函数长度合理（<100行）
- [ ] 代码复杂度合格（圈复杂度<10）
- [ ] 变量命名清晰
- [ ] 关键逻辑有注释
- [ ] 无硬编码配置
- [ ] 错误处理完整

**工具**：使用项目对应语言的 Linter + 复杂度分析工具

**通过标准**：
- ✅ L1 全部通过
- ✅ 无3次以上重复代码
- ✅ 函数长度<100行
- ✅ 圈复杂度<10

### L3 - 全面审查

**适用场景**：重大重构/发版前

**检查清单**：
- [ ] 全部文件格式检查通过
- [ ] 无重复3次以上的代码
- [ ] 代码复杂度合格（<10）
- [ ] 架构合理性审查
- [ ] 性能隐患排查
- [ ] 安全问题扫描
- [ ] 所有 TODO 已处理
- [ ] 文档已更新

**执行方式**：
- 使用工具扫描全部代码
- 手动审查关键模块
- 生成审查报告

**通过标准**：
- ✅ L2 全部通过
- ✅ 代码格式100%符合项目规范
- ✅ 重复代码率<3%
- ✅ 架构合理
- ✅ 文档完整

### 审查结果处理

```
发现问题
  ↓
严重程度？
  ├─ 致命（语法错误） → 立即修复，阻止提交
  ├─ 严重（重复>5次） → 当天修复
  ├─ 一般（重复3次） → 本周修复
  └─ 轻微（建议优化） → 记录TODO，按优先级处理
```

---

## 三、重复代码规则

### 何时提取公共代码

| 重复次数 | 行数 | 操作 | 理由 |
|---------|------|------|------|
| 1-2次 | 任意 | ❌ 不提取 | 可能是偶然重复 |
| 3次 | <5行 | ⚠️ 考虑提取 | 权衡提取成本 |
| 3次 | 5-20行 | ✅ 必须提取 | 明确的重复模式 |
| 3次 | >20行 | ✅ 必须提取 | 重大重复 |
| 4次+ | 任意 | ✅ 必须提取 | 无论多少行 |

### 不应该提取的"重复"

| 场景 | 原因 | 示例 |
|-----|------|------|
| CRUD层的标准操作 | 每个操作有不同的业务语义 | get/create/update/delete |
| 初始化代码 | 一次性执行，不会修改 | 数据库初始化脚本 |
| 测试用例 | 独立性比复用更重要 | 单元测试 |
| 配置文件 | 结构相似但语义不同 | 不同环境的配置 |
| 底层工具函数 | 已经是最小粒度 | 基础的get/set |

### 重复代码提取决策树

```
发现重复代码
  ↓
重复几次？
  ├─ 1-2次 → ❌ 不提取，保持原地实现
  ├─ 3次 → 继续判断
  │   ├─ <5行 → 权衡：提取成本 vs 维护成本
  │   │   ├─ 简单逻辑 → ⚠️ 可选提取
  │   │   └─ 复杂逻辑 → ✅ 提取
  │   └─ ≥5行 → ✅ 必须提取
  └─ 4次+ → ✅ 必须提取，无论行数

提取后检查：
  ├─ 是否降低了可读性？ → 是 → 回滚
  ├─ 是否增加了复杂度？ → 是 → 回滚
  └─ 是否真正减少维护成本？ → 否 → 回滚
```

---

## 四、反模式识别

### 常见反模式

| 反模式 | 描述 | 后果 | 正确做法 |
|-------|------|------|---------|
| 过早抽象 | 重复<3次就提取 | 增加复杂度 | 等到3次再提取 |
| 过度抽象 | 抽象层次>3层 | 难以理解 | 保持扁平 |
| 上帝类 | 单文件>2000行 | 难以维护 | 拆分模块 |
| 魔法数字 | 硬编码常量 | 难以修改 | 使用常量 |
| 长函数 | >100行 | 难以理解 | 拆分函数 |
| 深嵌套 | 嵌套>4层 | 难以理解 | 提前返回 |

### 识别方法

- 使用复杂度分析工具查找长函数和复杂函数
- 使用文件统计工具查找大文件
- IDE 内置的代码分析功能

---

## 五、实际案例

### 案例1：formatTime函数

**发现**：7个组件中重复定义
```javascript
// Account.vue, LogView.vue, Dashboard.vue... (7处)
const formatTime = (time) => {
  if (!time) return '-'
  const date = new Date(time)
  return date.toLocaleString('zh-CN')
}
```

**决策**：✅ 提取
- 重复次数：7次（>>3）
- 行数：5行
- 逻辑：完全一致

**行动**：
```javascript
// src/utils/format.js
export function formatTime(time) {
  if (!time) return '-'
  const date = new Date(time)
  return date.toLocaleString('zh-CN')
}

// 各组件
import { formatTime } from '@/utils/format'
```

**结果**：删除35行重复代码（7×5）

---

### 案例2：CRUD层的查询

**发现**：38次 db.query 在 crud/agency.py
```python
def get(self, db, id): 
    return db.query(Agency).filter(Agency.id == id).first()

def get_by_name(self, db, name):
    return db.query(Agency).filter(Agency.name == name).first()
```

**决策**：❌ 不提取
- 重复次数：38次（虽然多）
- 场景：CRUD层标准操作
- 原因：每个方法有不同的业务语义和过滤条件

**理由**：
- CRUD层本身就是数据访问的抽象层
- 每个查询有不同的过滤条件
- 强行提取会降低可读性

---

### 案例3：OAuthApp查询

**发现**：8处重复的查询+错误处理
```python
# 8个service文件中
oauth_app = db.query(OAuthApp).filter(OAuthApp.id == id).first()
if not oauth_app:
    raise ExternalApiCallError("OAuth应用不存在")
```

**决策**：✅ 提取
- 重复次数：8次（>>3）
- 行数：3行
- 逻辑：完全一致

**行动**：
```python
# utils/db_helpers.py
def get_oauth_app_by_id(db, oauth_app_id, error_message="OAuth应用不存在"):
    oauth_app = db.query(OAuthApp).filter(OAuthApp.id == oauth_app_id).first()
    if not oauth_app:
        raise HTTPException(status_code=404, detail=error_message)
    return oauth_app

# 各service
from app.utils.db_helpers import get_oauth_app_by_id
oauth_app = get_oauth_app_by_id(db, oauth_app_id)
```

**结果**：删除21行重复代码（8×3-3）
